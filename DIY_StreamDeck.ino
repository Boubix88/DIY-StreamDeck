// Aide : https://www.waveshare.com/wiki/1.28inch_LCD_Module#Resources
// Aide : https://dronebotworkshop.com/gc9a01/

#include <Adafruit_GFX.h>
#include <Adafruit_GC9A01A.h>
#include <HID-Project.h>
#include <HID-Settings.h>
#include <ArduinoJson.h>
#include <ArduinoJson.hpp>
#include <WS2812.h>

#define BOUTON_PLAY 2
#define BOUTON_PREVIOUS 3
#define BOUTON_NEXT 4
#define PLAY 0x78

#define TFT_DC 7
#define TFT_CS 10
#define TFT_RST 8

#define NB_LED 14
#define PIN_LED 9

#define DEG2RAD 0.0174532925

#define icon_cpu_width 64
#define icon_cpu_height 64

const unsigned char PROGMEM icon_cpu[] = {
   0x00, 0xe0, 0x07, 0x1f, 0xf8, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x87, 0x3f,
   0xfc, 0xe1, 0x07, 0x00, 0x00, 0xf0, 0x8f, 0x3f, 0xfc, 0xf1, 0x0f, 0x00,
   0x00, 0x70, 0x8e, 0x3b, 0xdc, 0x71, 0x0e, 0x00, 0x00, 0x70, 0x8e, 0x3b,
   0xdc, 0x71, 0x0e, 0x00, 0x00, 0x70, 0x8e, 0x3b, 0xdc, 0x71, 0x0e, 0x00,
   0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x80, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
   0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0xc0, 0xf9, 0xff, 0xff,
   0xff, 0xff, 0x9f, 0x03, 0xc0, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x03,
   0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x3f, 0xff, 0x1d, 0x00, 0x00,
   0x00, 0x00, 0xb8, 0xff, 0xff, 0x9d, 0x0f, 0x00, 0x00, 0x00, 0xb8, 0xff,
   0xc7, 0xdd, 0x1f, 0x00, 0x00, 0x00, 0xb8, 0xe3, 0xc7, 0xdd, 0x1f, 0x00,
   0x00, 0x00, 0xb8, 0xe3, 0xff, 0xdd, 0x0f, 0x00, 0x00, 0x00, 0xb8, 0xff,
   0xff, 0xdd, 0x03, 0x00, 0x00, 0x00, 0xb8, 0xff, 0xfc, 0xdd, 0x03, 0x00,
   0x00, 0x00, 0xb8, 0x3f, 0xc0, 0x9d, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x03,
   0xc0, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x03, 0xc0, 0x1d, 0x00, 0x00,
   0x00, 0x00, 0xb8, 0x03, 0xfe, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x7f,
   0xff, 0x1d, 0xf8, 0xf8, 0xc3, 0x61, 0xb8, 0xff, 0xff, 0x1d, 0xfc, 0xf9,
   0xcf, 0x71, 0xb8, 0xff, 0xc7, 0x1d, 0xfe, 0xfb, 0xcf, 0x71, 0xb8, 0xe3,
   0xff, 0x1d, 0xde, 0x3b, 0xde, 0x71, 0xb8, 0xff, 0xff, 0x1d, 0x8e, 0x3b,
   0xdc, 0x71, 0xb8, 0xff, 0xfe, 0x1d, 0x8e, 0x3b, 0xde, 0x71, 0xb8, 0x7f,
   0xc0, 0x1d, 0x0e, 0xf8, 0xdf, 0x71, 0xb8, 0x03, 0xc0, 0x1d, 0x0e, 0xf8,
   0xcf, 0x71, 0xb8, 0x03, 0xc0, 0x1d, 0x0e, 0xf8, 0xc7, 0x71, 0xb8, 0x03,
   0xc0, 0x1d, 0x0e, 0xf8, 0xc1, 0x71, 0xb8, 0x03, 0xfe, 0x1d, 0x8e, 0x3b,
   0xc0, 0x71, 0xb8, 0x7f, 0xff, 0x1d, 0x8e, 0x3b, 0xc0, 0x71, 0xb8, 0xff,
   0xff, 0x1d, 0xde, 0x3b, 0xc0, 0x7b, 0xb8, 0xff, 0xc7, 0x1d, 0xfe, 0x3b,
   0xc0, 0x7f, 0xb8, 0xe3, 0xff, 0x1d, 0xfc, 0x39, 0x80, 0x3f, 0xb8, 0xff,
   0xff, 0x1d, 0xf8, 0x38, 0x00, 0x1f, 0xb8, 0xff, 0xfe, 0x1d, 0x00, 0x00,
   0x00, 0x00, 0xb8, 0x7f, 0xc0, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x03,
   0xc0, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x03, 0xc0, 0x1d, 0x00, 0x00,
   0x00, 0x00, 0xb8, 0x03, 0xfc, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x3f,
   0xff, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xb8, 0xff, 0xff, 0x1d, 0x00, 0x00,
   0x00, 0x00, 0xb8, 0xff, 0xc7, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xb8, 0xe3,
   0xc7, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xb8, 0xe3, 0xff, 0x1d, 0x00, 0x00,
   0x00, 0x00, 0xb8, 0xff, 0xff, 0x1d, 0x00, 0x00, 0x00, 0x00, 0xb8, 0xff,
   0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x3f, 0xc0, 0xfd, 0xff, 0xff,
   0xff, 0xff, 0xbf, 0x03, 0xc0, 0xf9, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x03,
   0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x80, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
   0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x70, 0x8e, 0x3b,
   0xdc, 0x71, 0x0e, 0x00, 0x00, 0x70, 0x8e, 0x3b, 0xdc, 0x71, 0x0e, 0x00,
   0x00, 0x70, 0x8e, 0x3b, 0xdc, 0x71, 0x0e, 0x00, 0x00, 0xf0, 0x8f, 0x3f,
   0xfc, 0xf1, 0x0f, 0x00, 0x00, 0xe0, 0x87, 0x3f, 0xfc, 0xe1, 0x07, 0x00,
   0x00, 0xe0, 0x07, 0x1f, 0xf8, 0xe0, 0x07, 0x00 };

#define icon_gpu_width 64
#define icon_gpu_height 64
const unsigned char PROGMEM icon_gpu[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x07, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x7f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x07, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x7e, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x70, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x7f, 0x70, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x7e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x07, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x7f, 0xe7, 0x03, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0x77, 0xf7, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x77, 0xf7, 0x07, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0x77, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x77, 0x77, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x77, 0x67, 0x80, 0x1f, 0x7f, 0x1c, 0x0e, 0xe0,
   0x7f, 0x07, 0xc0, 0x3f, 0xff, 0x1c, 0x0e, 0xe0, 0x7f, 0x07, 0xe0, 0x3f,
   0xff, 0x1d, 0x0e, 0xe0, 0x7e, 0x07, 0xe0, 0x38, 0xe7, 0x1d, 0x0e, 0xe0,
   0x70, 0x07, 0xe0, 0x38, 0xc7, 0x1d, 0x0e, 0xe0, 0x7f, 0x07, 0xe0, 0x38,
   0xe7, 0x1d, 0x0e, 0xe0, 0x7f, 0x07, 0xe0, 0x00, 0xff, 0x1d, 0x0e, 0xe0,
   0x7f, 0x07, 0xe0, 0x3e, 0xff, 0x1c, 0x0e, 0xe0, 0x77, 0x07, 0xe0, 0x3e,
   0x7f, 0x1c, 0x0e, 0xe0, 0x77, 0x07, 0xe0, 0x3e, 0x07, 0x1c, 0x0e, 0xe0,
   0x77, 0x07, 0xe0, 0x38, 0x07, 0x1c, 0x0e, 0xe0, 0x77, 0x07, 0xe0, 0x38,
   0x07, 0x3c, 0x0f, 0xe0, 0x77, 0x07, 0xe0, 0x3f, 0x07, 0xfc, 0x07, 0xe0,
   0x77, 0x07, 0xc0, 0x3f, 0x07, 0xf8, 0x07, 0xe0, 0x77, 0x07, 0xc0, 0x1f,
   0x07, 0xf0, 0x03, 0xe0, 0x77, 0x07, 0x00, 0x06, 0x03, 0xc0, 0x00, 0xe0,
   0x77, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x77, 0x07, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x77, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0x7f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x7f, 0x07, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x7f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0x70, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x70, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
   0x70, 0x77, 0x9c, 0x73, 0xce, 0x39, 0xce, 0x39, 0x70, 0xf7, 0xff, 0x7f,
   0xfe, 0xff, 0xff, 0x3f, 0xf0, 0xf7, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x3f,
   0xf0, 0xe7, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x3f, 0xe0, 0x03, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#define volume_icon_width 100
#define volume_icon_height 100
const unsigned char volume_icon[] PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x0f,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
   0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xfe, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x80, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x1f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x1f, 0x00,
   0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x1f,
   0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff,
   0x1f, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,
   0xff, 0x1f, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc,
   0xff, 0xff, 0x1f, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xfe, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xff, 0x07, 0x00, 0x00, 0x00,
   0x00, 0xc0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xfe, 0x0f, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xfc, 0x1f, 0x00,
   0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xf8, 0x1f,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x1f, 0xf0,
   0x3f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x1f, 0x80, 0x3f,
   0xe0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x80,
   0x7f, 0xe0, 0x7f, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x1f,
   0x80, 0xff, 0xc0, 0xff, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x1f, 0x80, 0xff, 0x81, 0xff, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0x1f, 0x80, 0xff, 0x81, 0xff, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x1f, 0x80, 0xff, 0x03, 0xff, 0x01, 0xfe, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x1f, 0x00, 0xff, 0x07, 0xfe, 0x01, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xfe, 0x07, 0xfe, 0x03, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xfc, 0x0f, 0xfe, 0x03, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xf8, 0x0f, 0xfc, 0x03,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xf8, 0x1f, 0xfc,
   0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xf0, 0x1f,
   0xf8, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xe0,
   0x1f, 0xf8, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00,
   0xe0, 0x3f, 0xf8, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
   0x00, 0xc0, 0x3f, 0xf8, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x1f, 0x00, 0xc0, 0x3f, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0x1f, 0x00, 0xc0, 0x3f, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x1f, 0x00, 0x80, 0x7f, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x1f, 0x00, 0x80, 0x7f, 0xf0, 0x0f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x80, 0x7f, 0xf0, 0x0f, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x80, 0x7f, 0xe0, 0x0f, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x80, 0x7f, 0xe0, 0x0f,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x80, 0x7f, 0xe0,
   0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x80, 0x7f,
   0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x80,
   0x7f, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00,
   0x80, 0x7f, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
   0x00, 0x80, 0x7f, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x1f, 0x00, 0x80, 0x7f, 0xe0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0x1f, 0x00, 0x80, 0x7f, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x1f, 0x00, 0x80, 0x7f, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x1f, 0x00, 0x80, 0x7f, 0xf0, 0x0f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xc0, 0x3f, 0xf0, 0x0f, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xc0, 0x3f, 0xf0, 0x0f, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xc0, 0x3f, 0xf8, 0x0f,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xe0, 0x3f, 0xf8,
   0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xe0, 0x1f,
   0xf8, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xf0,
   0x1f, 0xf8, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00,
   0xf8, 0x1f, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
   0x00, 0xf8, 0x0f, 0xfc, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x1f, 0x00, 0xfc, 0x0f, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0x1f, 0x00, 0xfe, 0x07, 0xfe, 0x03, 0xfe, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x1f, 0x00, 0xff, 0x07, 0xfe, 0x01, 0xfe, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x1f, 0x80, 0xff, 0x03, 0xff, 0x01, 0xf8, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x1f, 0x80, 0xff, 0x81, 0xff, 0x00, 0xc0, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x80, 0xff, 0x81, 0xff, 0x00, 0x00,
   0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x80, 0xff, 0xc0, 0xff, 0x00,
   0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x80, 0x7f, 0xe0, 0x7f,
   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x1f, 0x80, 0x3f, 0xe0,
   0x3f, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x1f,
   0xf0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0x00,
   0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x1f,
   0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff,
   0x1f, 0x00, 0x00, 0xfe, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0xff, 0x1f, 0x00, 0x00, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
   0xff, 0xff, 0x1f, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xfc, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x7e, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x18, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x1f, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x1f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x1f,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff,
   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };



Adafruit_GC9A01A tft = Adafruit_GC9A01A(TFT_CS, TFT_DC, TFT_RST);

char lastScreen = 'c';
char currentScreen = '?';

// Variables pour le chrono
unsigned long MS; 
unsigned long start;
unsigned long tmpStart;
const long resetInterval = 4;  // Intervalle de temps pour réinitialiser le timer

uint8_t lastVolume = 0;
uint8_t lastCpuTemp = 0;
uint8_t lastGpuTemp = 0;

uint8_t indexLed = 0;
uint8_t iterationDispVol = 0;

//Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NB_LED,PIN_LED, NEO_GRB + NEO_KHZ800);
WS2812 LED(NB_LED); // 14 LEDs
cRGB value;

void startScreen() {
    // On remet toutes les anciennes valeurs à 0 pour pas que l'affichage bug
    lastVolume = 0;
    lastCpuTemp = 0;
    lastGpuTemp = 0; 
    iterationDispVol = 0;

    tft.setCursor(40, 115);
    tft.setTextSize(2);
    tft.setTextColor(GC9A01A_WHITE);
    tft.println("Connection ..."); // Afficher connecion ...

    value.r = 0, value.g = 0, value.b = 0;
    for(uint8_t i=0; i<NB_LED; i++){ // On parcour toute les leds pour les éteindre
      LED.set_crgb_at(i, value);
      LED.sync();
    }

    // Chargement led bleue
    for(uint8_t i=0; i<NB_LED; i++){ // On parcour toute les leds
      if (Serial.available() > 0) { // Si on detecte une connexion au PC
        return;
      } else {
        for (uint8_t j = 0; j < 255; j++) {
          value.b = j;
          LED.set_crgb_at(i, value);
          LED.sync();
          delay(1);
        }
        delay(1);
      }
    }
}

uint8_t fillArc(uint8_t x, uint8_t y, uint8_t start_angle, uint8_t seg_count, uint8_t rx, uint8_t ry, uint8_t w, uint8_t colour){
    byte seg = 3; // Segments are 3 degrees wide = 120 segments for 360 degrees
    byte inc = 3; // Draw segments every 3 degrees, increase to 6 for segmented ring

    // Calculate first pair of coordinates for segment start
    float sx = cos((start_angle - 90) * DEG2RAD);
    float sy = sin((start_angle - 90) * DEG2RAD);
    uint8_t x0 = sx * (rx - w) + x;
    uint8_t y0 = sy * (ry - w) + y;
    uint8_t x1 = sx * rx + x;
    uint8_t y1 = sy * ry + y;

  // Draw colour blocks every inc degrees
  for (uint8_t i = start_angle; i < start_angle + seg * seg_count; i += inc) {
    // Calculate pair of coordinates for segment end
    float sx2 = cos((i + seg - 90) * DEG2RAD);
    float sy2 = sin((i + seg - 90) * DEG2RAD);
    uint8_t x2 = sx2 * (rx - w) + x;
    uint8_t y2 = sy2 * (ry - w) + y;
    uint8_t x3 = sx2 * rx + x;
    uint8_t y3 = sy2 * ry + y;

    tft.fillTriangle(x0, y0, x1, y1, x2, y2, colour);
    tft.fillTriangle(x1, y1, x2, y2, x3, y3, colour);

    // Copy segment end to sgement start for next segment
    x0 = x2;
    y0 = y2;
    x1 = x3;
    y1 = y3;
  }
}


// TODO : Si le volume augmente ne déssiner que la partie de l'arc en plus à rajouter, ne rien effacer, si le volume baisse dessiner en noir la partie de l'arc à retirer
void displayVolume(uint8_t receivedVolume){
    // Calcul de l'angle pour représenter le volume
    uint8_t volumeAngle = (uint8_t) map(receivedVolume, 0, 100, 0, 360); // Volume en pourcentage vers angle en degre

    /*Serial.print("Angle : ");
    Serial.println(volumeAngle);*/

    // Centre du cercle
    uint8_t centerX = tft.width() / 2;
    uint8_t centerY = tft.height() / 2;

    // Si le volume de base est à 0 OU on est si on entre pour la première fois dans la fonction
    if (lastVolume == 0 || iterationDispVol == 0) {
      // On dessine l'arc pour le volume du son
      tft.fillScreen(GC9A01A_BLACK);
      fillArc(centerX, centerY, 0, volumeAngle/3, centerX, centerY, 20, GC9A01A_BLUE);
    }

    // on affiche seulement si le volume est différent de la dernière fois
    if (lastVolume != receivedVolume && lastVolume != 0) {
      // Calculer la différence entre le volume actuel et le volume reçu
      int8_t volumeDifference = receivedVolume - lastVolume;

      // Si le volume augmente, ajoutez une partie de l'arc
      if (volumeDifference > 0) {
          // Dessinez l'arc supplémentaire
          uint8_t newVolumeAngle = (uint8_t) map(volumeDifference, 0, 100, 0, 360); // Volume en pourcentage vers angle en degre
          fillArc(centerX, centerY, volumeAngle, newVolumeAngle / 3, centerX, centerY, 20, GC9A01A_BLUE);
      }
      // Si le volume diminue, effacez une partie de l'arc en noir
      else if (volumeDifference < 0) {
          // Effacer l'arc avec la couleur de fond
          uint8_t newVolumeAngle = (uint8_t) map(-volumeDifference, 0, 100, 0, 360); // Volume en pourcentage vers angle en degre
          fillArc(centerX, centerY, volumeAngle - newVolumeAngle, newVolumeAngle / 3, centerX, centerY, 20, GC9A01A_BLACK);
      }

      // Afficher l'icône de volume au milieu de l'écran
      //tft.drawXBitmap(70, 30, volume_icon, volume_icon_width, volume_icon_height, GC9A01A_WHITE);

      // Afficher le texte du volume en dessous de l'icône
      tft.fillRect(70, 150, 90, 60, GC9A01A_BLACK);
      if (receivedVolume >=0 && receivedVolume < 10) {
        tft.setCursor(100, 150);
      } else {
        tft.setCursor(70, 150);
      }
      tft.setTextSize(8);
      tft.setTextColor(GC9A01A_WHITE);
      tft.println(receivedVolume); // Afficher le volume
    }

    iterationDispVol++;
}

void displayTemp(uint8_t cpuTemp, uint8_t gpuTemp) {
    // Afficher l'icône de CPU en haut
    tft.drawXBitmap(50, 50, icon_cpu, icon_cpu_width, icon_cpu_height, GC9A01A_WHITE);

    tft.setTextSize(5);
    tft.setTextColor(GC9A01A_WHITE);

    tft.setCursor(130, 60);
    if (cpuTemp != lastCpuTemp) {
      tft.fillRect(130, 60, 80, 80, GC9A01A_BLACK);
      tft.println(cpuTemp); // Afficher la temperature cpu
    }
    
    // Afficher l'icône de GPU en bas
    tft.drawXBitmap(50, 130, icon_gpu, icon_gpu_width, icon_gpu_height, GC9A01A_WHITE);

    tft.setCursor(130, 145);
    if (gpuTemp != lastGpuTemp){
      tft.fillRect(130, 145, 80, 80, GC9A01A_BLACK);
      tft.println(gpuTemp); // Afficher la temperature gpu
    } 
}

void setStaticLedColor(uint8_t r, uint8_t g, uint8_t b) {
    //pixels.clear(); //On éteuint8_t les leds allumé
    for(uint8_t i=0; i < NB_LED; i++){ // On parcour toute les leds
      value.r = r; value.g = g; value.b = b;
      LED.set_crgb_at(i, value);
    }

    LED.sync();
}

void rainbow(uint8_t wait) {
  //Serial.println("Rainbow");

  if (indexLed >= 0 && indexLed < 256) {
    for (uint8_t i = 0; i < NB_LED; i++) {
      LED.set_crgb_at(i, Wheel((i + indexLed) & 255));
    }
    LED.sync();
    indexLed += wait/10;
  } else if (indexLed >= 256) {
    indexLed = 0;
  }
}

cRGB Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
  cRGB color;

  if (WheelPos < 85) {
    color.r = 255 - WheelPos * 3;
    color.g = 0;
    color.b = WheelPos * 3;
  } else if (WheelPos < 170) {
    WheelPos -= 85;
    color.r = 0;
    color.g = WheelPos * 3;
    color.b = 255 - WheelPos * 3;
  } else {
    WheelPos -= 170;
    color.r = WheelPos * 3;
    color.g = 255 - WheelPos * 3;
    color.b = 0;
  }
  return color;
}

void rainbowCycle(uint8_t wait) {
  //Serial.println("Rainbow cycle");

  if (indexLed >= 0 && indexLed < 256*5) { // 5 cycles of all colors on wheel
    for(uint8_t i=0; i< NB_LED; i++) {
      LED.set_crgb_at(i, Wheel(((i * 256 / NB_LED) + indexLed) & 255));
    }
    LED.sync();
    indexLed += wait/10;
  } else if (indexLed >= 256*5) {
    indexLed = 0;
  }
}

void processReceivedData() {
  // Obtient le temps actuel
  MS = millis()-start;

  /*Serial.print(F("Arduino : "));
  Serial.print((MS / 1000) / 60);
  Serial.print(F(" : "));
  Serial.print((MS / 1000) % 60);
  Serial.print(F(" : "));
  Serial.println(MS % 1000);*/

  uint8_t seconde = (MS / 1000) % 60;;

  // Vérifie si le port série est prêt à être écrit
  if (Serial.availableForWrite()) {
    /*Serial.print(F("Arduino : "));
    Serial.print(seconde);
    Serial.print(F(" <= "));
    Serial.print(resetInterval);
    Serial.print(F("  ---  ecran : "));
    Serial.print(currentScreen);
    Serial.print(F("   ----   Start : "));
    Serial.println(start);*/
    /*Serial.print(F("Index LED : "));
    Serial.println(indexLed);*/
  }


  if (Serial.available() > 0) {
    // Lecture des données JSON envoyées par le port série
    StaticJsonDocument<300> jsonDocument;
    DeserializationError error = deserializeJson(jsonDocument, Serial);

    if (error) {
      // Gestion des erreurs de lecture JSON
      /*Serial.print(F("deserializeJson() failed: "));
      Serial.println(error.c_str());*/
      return;
    }

    // Vérification du type de données reçu
    uint8_t volume = jsonDocument["volume"];
    if (/*jsonDocument.containsKey("volume") || */(currentScreen == 'v'/* && milliS != -1*/) || lastVolume != volume) {
      lastCpuTemp = 0;
      lastGpuTemp = 0; 
    
      // On réactive le chrono
      if (start == 0 || start == tmpStart) {
        start = millis();
      } else if (seconde > resetInterval) { // Si les 3s sont ecoulées alors on réinitialise millis
        //milliS = -1;
        start = millis();
        currentScreen = 'c';
      } else {
        currentScreen = 'v';
      }

      if (lastScreen == 't' || lastScreen == 'c') {
        // Effacer l'écran précédent
        tft.fillScreen(GC9A01A_BLACK);
      }

      //previousMillis = currentMillis;  // Sauvegarde le temps actuel

      // Si le JSON contient la clé "volume", on récupère la valeur du volume
      volume = jsonDocument["volume"];
      displayVolume(volume);
      lastVolume = volume;
      lastScreen = 'v';
    } else if (jsonDocument.containsKey("temperature")/*jsonDocument.containsKey("cpu") && jsonDocument.containsKey("gpu")*/) {
      iterationDispVol = 0;

      if (lastScreen == 'v' || lastScreen == 'c') {
        // Effacer l'écran précédent
        tft.fillScreen(GC9A01A_BLACK);
      }

      // Si le JSON contient les clés "cpu" et "gpu", on récupère les valeurs de température CPU et GPU
      uint8_t cpuTemp = jsonDocument["temperature"]["cpu"];
      uint8_t gpuTemp = jsonDocument["temperature"]["gpu"];
      displayTemp(cpuTemp, gpuTemp);
      lastScreen = 't';
      lastCpuTemp = cpuTemp;
      lastGpuTemp = gpuTemp;
    }
    
    // Gestion de la couleur du ruban
    if (jsonDocument.containsKey("color")) {
      // on verifie le type du RGB
      uint8_t mode = jsonDocument["color"]["Mode"];

      if (mode == 1) { // Mode statique
        uint8_t brightness = jsonDocument["color"]["Brightness"];
        uint8_t r = (uint8_t) jsonDocument["color"]["R"] * (brightness / 100.0);
        uint8_t g = (uint8_t) jsonDocument["color"]["G"] * (brightness / 100.0);
        uint8_t b = (uint8_t) jsonDocument["color"]["B"] * (brightness / 100.0);

        setStaticLedColor(r, g, b);
      } else if (mode == 2) { // Défilement statique
        uint8_t speed = jsonDocument["color"]["Speed"];
        rainbow(speed);
      } else if (mode == 3) { // Défilement RGB
        uint8_t speed = jsonDocument["color"]["Speed"];
        rainbowCycle(speed);
      }
    }
  } else {
    if (lastScreen != 'c') {
      // Effacer l'écran précédent
      tft.fillScreen(GC9A01A_BLACK);
    }

    startScreen();
    lastScreen = 'c';
  }
}

void setup() {
  // Initialisation du bouton 1
  pinMode(BOUTON_PLAY,INPUT_PULLUP);

  // Initialisation de la communication série
  Serial.begin(2000000);

  // begin HID connection
  Consumer.begin();

  // Initialisation des leds
  LED.setOutput(PIN_LED);
  LED.setColorOrderGRB();
  value.r = 0, value.g = 0, value.b = 0;
  
  // On initialise l'ecran
  tft.begin();
  tft.fillScreen(GC9A01A_BLACK);
  
  // Attente de la connexion au port série
  while (!Serial) {
    startScreen();
  }

  start = 0;
  tmpStart = start;
}

void loop() {
  // Bouton PLAY/PAUSE
  if (digitalRead(BOUTON_PLAY) == LOW) {
    //Serial.println("Play/Pause");

    // On envoi la commande
    Consumer.write(MEDIA_PLAY_PAUSE);

    delay(200);
  }

  // On recoit des données donc on affiche le volume
  processReceivedData();
}